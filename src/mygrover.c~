void apply_grover_oracle(QubitState *state) {
    // Oracolo che inverte il segno dello stato target |1010> (stato 10 in base decimale)
    
    // Applica gate X per mappare |1010> a |1111> per applicare il controllo
    applyX(state, 0); // Inverti qubit 0
    applyX(state, 2); // Inverti qubit 2

    // Applica un gate Z controllato a tutti i qubit (multicontrollato)
    applyControlledZ(state, 0, 1);
    applyControlledZ(state, 1, 2);
    applyControlledZ(state, 2, 3);

    // Re-inverti i qubit per tornare allo stato |1010>
    applyX(state, 0);
    applyX(state, 2);
}

void apply_grover_diffusion(QubitState *state) {
    // Applica l'operatore di diffusione (inversione rispetto alla media)
    
    // Applica Hadamard a tutti i qubit
    for (int i = 0; i < 4; i++) {
        applyHadamard(state, i);
    }

    // Inverti rispetto allo stato |0000>
    for (int i = 0; i < 4; i++) {
        applyX(state, i);
    }

    // Applica un Z controllato a tutti i qubit per riflettere rispetto a |0000>
    applyControlledZ(state, 0, 1);
    applyControlledZ(state, 1, 2);
    applyControlledZ(state, 2, 3);

    // Re-inverti i qubit
    for (int i = 0; i < 4; i++) {
        applyX(state, i);
    }

    // Applica Hadamard a tutti i qubit di nuovo
    for (int i = 0; i < 4; i++) {
        applyHadamard(state, i);
    }
}

void circuit(QubitState *state) {
    // Inizializza lo stato di tutti i qubit in una sovrapposizione uniforme
    for (int i = 0; i < 4; i++) {
        applyHadamard(state, i);
    }

    // Numero di ripetizioni di Grover, approssimativamente sqrt(16) = 4
    int num_iterations = 4;

    // Esegui l'algoritmo di Grover
    for (int i = 0; i < num_iterations; i++) {
        apply_grover_oracle(state);        // Applica l'oracolo
        apply_grover_diffusion(state);     // Applica l'operatore di diffusione
    }
}
